/*
작성자 : 이광민
일시 : 2021.07.07
제목 : 10942 - 팰린드롬?
풀이 : 수열이 주어지고 수열의 범위가 입력으로 주어진다.
       이 때, 범위의 수열이 팰린드롬인지 아닌지를 판단하는 문제이다.

	   팰린드롬이란. 앞에서부터 읽어도 뒤에서부터 읽은 수열과 동일한 수열이다.
	   이를 다시 말하면 주어진 범위가 S와 E라고 할 때
	   Arr[S]와 Arr[E]가 같으면 이는 더 탐색할 필요가 있는 수열이고
	   Arr[S]와 Arr[E]가 다르면 이는 더 탐색할 필요 없이 팰린드롬이 아닌 수열이다.

	   그렇기 때문에 재귀를 통해 DP를 진행하면 된다.
	   (나는 재귀를 통해 풀이를 하였고, 비재귀를 통한 풀이도 가능하다 풀이를 작성하고 후술하겠다)

	   두가지 경우를 통해 탐색을 진행하면 된다. 위에서 말한것 처럼
	   S와 E를 입력받아 Arr[S]와 Arr[E]가 같다면 go(S+1, E-1)을 통해 추가로 탐색을 진행하면 되고
	   Arr[S]와 Arr[E]가 다르다면 이는 팰린드롬이 아니기 때문에 바로 불가능(0)을 저장하고 리턴해주면 된다.
	   탐색을 진행하며 S와 E가 같아지거나(범위가 홀수인 경우) S가 E보다 커지는 경우(범위가 짝수인 경우) 
	   이는 앞서 말한 모든 Arr[S]와 Arr[E]가 같았다는 말이기 때문에 1을 리턴해주면 된다.

	   주어진 값에서 중복을 제거하기 위해 메모제이션 방식을 사용하고 굳이 모든 경우를 탐색하여 처리할 필요는 없기 때문에
	   입력되는 범위에 대해서만 처리하도록 한다.

	   비재귀의 경우
	   1. 길이가 1인 -> 모두 팰린드롬
	   2. 길이가 2인 -> Arr[i] == Arr[i+1] 이면 팰린드롬
	   3. 길이가 3 이상인 -> 앞 뒤가 같고 그 사이에 있는 수들이 팰린드롬이면 팰린드롬
	   이 3가지의 경우를 반복문을 나누어 처리해주면 된다.
*/
#include<iostream>
#include<algorithm>

using namespace std;

int n, m;
int arr[2001];
int dp[2001][2001];

int go(int s, int e) {
	if (s >= e) return 1; 

	int &ret = dp[s][e];
	if (ret != -1) return ret;

	if (arr[s] == arr[e])
		ret = go(s + 1, e - 1);
	else
		ret = 0;

	return ret;
}

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> arr[i];

	for (int i = 0; i <= n; i++)
		for (int j = 0; j <= n; j++)
			dp[i][j] = -1;

	cin >> m;
	while (m--) {
		int s, e;
		cin >> s >> e;
		cout << go(s, e) << '\n';
	}
}