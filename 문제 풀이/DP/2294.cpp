/*
작성자 : 이광민
일시 : 2021.05.26
제목 : 2294 - 동전 2
풀이 : 동전 1 문제와 크게 다른게 없는 문제이다.
       n개의 수로 k를 만들고자 할 때 최소 개수의 수만 사용하여 k를 만드는 방법을 구하는 것

	   이는 다음과 같이 정의 된다.
	   가장 작은 단위로 k를 만든다 -> 가장 많은 개수를 사용해야 한다.
	   서로 다른 단위로 k를 만든다 -> 중간 개수 사용
	   가장 큰 단위로 k를 만든다 ->   가장 적은 개수를 사용

	   하지만, 가장 큰 단위로 항상 k를 만들 수 없기 때문에 위 과정을 거치면서 최소 개수를 구해야 한다.

	   방식은 동전 1과 매우 유사하다.

	   베이스가 되는 d배열의 값 -> INF (가장 큰 값에서 시작)
	   d[0] = 0 -> 0을 나타내기 위해 사용되는 수는 0개이기 때문이다.
	   그 이후 각 단위들에 대해 현재 d[j]에 저장되어 있는(최소 동전 개수) 수와 d[j - arr[i]] + 1 (현재 단위를 제외한 d[n]의 최소 + 1 개수) 를 비교하여 최소값을 저장
	   즉, 점화식은 d[j] = min(d[j], d[j - arr[i]] + 1)가 된다.
	   이를 진행하여 d[k]의 값이 INF라면 경우의 수가 존재하지 않기 때문에 -1을 출력 해준다.

	   착각한점
	   1. arr을 오름차순 정렬 해주어야 한다고 생각했다
	   2. d[0] = 1이 아닌 0
	   3. d배열의 초기값 

	   1 -> 각 경우의 최소값만을 가지고 가기 때문에 따로 정렬을 해주지 않아도 최소값으로 저장된다.
	   2 -> 0을 나타내기 위해 사용되는 수의 개수는 1개가 아닌 0개이다.
	   3 -> 초기값을 0으로 주고 조건문을 통해 처리하면 문제가 생기지만, 초기값을 INF로 두면 더욱 간단하고 빠르게 올바른 처리가 가능하다.
*/
#include <iostream>
#include <algorithm>

using namespace std;

const int INF = 987654321;
int n, k;
int d[10001];
int arr[101];

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	cin >> n >> k;
	for (int i = 0; i < n; i++)
		cin >> arr[i];
	//sort(arr, arr + n);
	for (int i = 1; i <= k; i++)
		d[i] = INF;
	d[0] = 0;
	for (int i = 0; i < n; i++) {
		for (int j = arr[i]; j <= k; j++) {
			d[j] = min(d[j], d[j - arr[i]] + 1);
		}
	}

	if (d[k] == INF) cout << -1;
	else cout << d[k];
}