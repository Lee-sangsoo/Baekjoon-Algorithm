/*
작성자 : 이광민
일시 : 2021.06.08
제목 : 5582 - 공통 부분 문자열
풀이 : LCS (Logest Common Substring) 문제이다.
       LCS는 크게 2가지가 있는디 마지막 S가 'Subsequence'이냐 'Substring'이냐로 나뉜다.
	   이 문제는 문자열을 구하는 문제이다.
	   (Subsequence : 연속하지 않는 부분 문자열 구하기) ---> 9251번 문제 확인하기
	   (Substring : 연속하는 부분 문자열 구하기)

	   점화식은 다음과 같다.
	   "DP[n][m] = 문자 A가 n번째 문자, B가 m번째 문자를 사용하고 있을 때 LCS의 길이"
	   subsequence 알고리즘에서 크게 달라지는게 없는 문제이다.

	   기존 subsequence 알고리즘이 문자가 일치할 때와 일치하지 않을때를 서로 비교했었다면
	   substring의 경우 연속하지 않으면 그 값이 0으로 존재하지 않기 때문에 
	   subsequence의 else부분을 제외해주면 간단하게 해결되는 알고리즘이다.

	   이 문제에서 두 반복문은 i번째, j번째 문자를 가리키는 것이며 
	   문자열에서 시작 인덱스는 0이기 때문에 
	   반복문의 i번째와 j번째는 a[i-1], b[j-1]이 된다.

	   즉, d[i][j]는 문자열의 몇번째를 가리키는지 수 그대로를 나타내고
	   a[i], b[i]는  문자열의 몇번째 인덱스인지를 나타내는 수이다.

	   ans를 찾는 부분은 후처리를 해도 되지만 간단하게 처리하기 위해 안쪽으로 집어 넣었다.

	   두가지 LCS 모두 다음과 같은 부분에서 시작된다.

	   어떤 문자열 A와 B가
	   ㅁㅁㅁㅁㅁㅁ ... 
	   ㅁㅁㅁㅁㅁㅁ ...  처럼 나타내어질 때

	   ㅁㅁㅁㅁㅁ i
	   ㅁㅁㅁㅁㅁ j   번째를 비교하여 보았을 때
	   A[i]와 B[j]가 같은가, 같지 않은가에서 시작되어진다.

	   이 문제에서는 같은 경우만 확인하면 되기 때문에
	   위 두가지에서 같다면 i와 j 이전인
	   ㅁㅁㅁㅁㅁ
	   ㅁㅁㅁㅁㅁ 인 부분의 LCS를 가져와서 +1 해주면 되기 때문이다.

	   같지 않다면 LCS가 연결되지 않기 때문에 무조건 0이된다.


	   만약 d[i][j]와 a[i], b[j]의 인덱스나 반복문의 값을 일치시키고 싶다면
	   a = " " + a;
	   b = " " + b;
	   와 같이 공백을 하나 추가하여 아무 값도 없는 것으로 시작되도록 처리하면 된다.
*/
#include <iostream>
#include <string>

using namespace std;

int d[4001][4001];

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	string a, b;
	cin >> a >> b;
	int ans = 0;
	for (int i = 1; i <= a.length(); i++) {
		for (int j = 1; j <= b.length(); j++) {
			if (a[i - 1] == b[j - 1]) {
				d[i][j] = d[i - 1][j - 1] + 1;
				if (ans < d[i][j]) ans = d[i][j];
			}
		}
	}
	cout << ans;
}