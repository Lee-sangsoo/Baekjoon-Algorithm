/*
작성자 : 이광민
일시 : 2021.06.07
제목 : 5557 - 1학년
풀이 : 어떤 문제에서 가끔 모든 경우를 생각하는 것 보다는 모든 값을 처리해보는게 더 빠를 수도 있다.

       이 문제는 특정 값들을 더하고 빼면서 그 값이 목표 값이 될 수 있는지 확인하는 문제이다.
	   그렇다 보니 수에서 수를 더하고 빼는 2가지 경우에 대해서 각 값들이 처리되고
	   그에 따라 범위가 0 ~ 20 까지의 수 뿐이지만 주어지는 수에 따라 그 경우의 수가 2^n가 되는 매우 큰 값이다.
	   이 문제에서 n의 범위는 최대 100이하이기 때문에 이 값을 모든 경우를 따져서 처리하는것은 불가능하다.

	   하지만, '경우의 수'가 아닌 '모든 값들의 처리'로 확인한다면 말이 다르다.
	   DP[N][X] = N번째 숫자를 사용하였을 때 값 X를 만들 수 있는 방법의 수
	   라고 정의하고 처리하게 된다면 이는
	   3 <= N <= 100, 0 <= X <= 20으로
	   모든 값들을 확인하여도 O(n * x) 안에 처리가 가능하다.

	   값을 빼고 더할 수 있기 때문에
	   첫번째 수를 베이스로 삼아
	   0부터 20까지 돌아가며 새로운 수와 이전의 수를 더하거나 뺐을 때 범위안에 들어간다면
	   이 전의 경우의 수를 새로운 경우의 수에 더해주면 된다.

	   느낀점
	   1. DP 문제는 처리 시간을 매우 많이 줄여준다.
	   2. 꼭 경우의 수라고 해서 브루트 포스를 생각할 필요는 없다.
	   3. 시간을 줄여야 하는 문제라면 DP적 접근을 하여 점화식을 어떻게 세울지 한번 생각해보자.
*/
#include <iostream>
#include <algorithm>

using namespace std;

int n;
int arr[101];
long long d[101][21];

void show() {
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= 20; j++) {
			cout << d[i][j] << ' ';
		}
		cout << '\n';
	}
}

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> arr[i];

	d[1][arr[1]] = 1;

	for (int i = 2; i <= n; i++) {
		for (int j = 0; j <= 20; j++) {
			if (d[i - 1][j] != 0) {
				if (j + arr[i] <= 20) d[i][j + arr[i]] += d[i - 1][j];
				if (j - arr[i] >= 0) d[i][j - arr[i]] += d[i - 1][j];
			}
		}
	}

	//show();

	cout << d[n - 1][arr[n]];
}