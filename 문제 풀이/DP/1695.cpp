/*
작성자 : 이광민
일시 : 2021.06.23
제목 : 1695 - 팰린드롬 만들기
풀이 : 동적 프로그래밍의 또다른 시야를 열어준 문제
       이때까지 DP[n]을 두었을 때 "어떤 것을 하는 횟수", "어떤 값을 처리하는 방법" 등의 처리였다면
	   이 문제는 DP[n][m]을 두어 "주어진 값들의 n부터 m까지"로 처리한다.

	   팰린드롬을 확인하는 방법을 원초적으로 생각해보자.
	   바로 처음과 끝을 확인하고 맞다면 처음+1과 끝-1을 확인 이렇게 반복하며 중앙까지 (처음 > 끝 이 되는 지점) 가는것이다.

	   이 문제는 팰린드롬인 수열이 주어질수도 있고 아닐수도 있다.
	   그렇기 때문에 처음에는 양 끝을 바라보고 시작한다.
	   처음을 가리키는 start, 끝을 가리키는 end를 두고 봤을 때
	   1. start와 end가 가리키는 값이 같다.
	   2. start와 end가 가리키는 값이 다르다.

	   이렇게 2가지의 경우가 나올 수 있다.
	   두 값이 같다면(1) 그냥 start는 +1 end는 -1을 해주고 다음 값을 확인하면 된다. 
	   (이 문제에서는 추가해야 하는 수가 몇개인지 확인해야 하는 문제이기 때문에 "추가하는 갯수에 중점을 두어 값의 추가는 없다")

	   두 값이 다르다면(2) 또 2가지 경우를 확인해야 한다.
	   예시의 1 2 3 4 2를 보면
	   처음 start와 end의 1과 2는 다르기 때문에
	   1) 1 앞에 2를 추가한다.
	   2) 2 뒤에 1을 추가한다. 의 2가지 경우가 생긴다.
	   즉, 2 1 2 3 4 2
	       1 2 3 4 2 1
	   을 두고 확인하는 것이다. 이 두가지 중에서 무엇이 최소 갯수를 가지는지는 모르기 때문에 탐색을 진행해준다.
	   그리고 둘 중 더 작은 값을 선택하도록 하면 되는것이다.

	   이를 쉽게 구현하는 방법은 재귀를 사용하여 구현하는것이 간단하다.
	   1)의 경우 end가 가리키는 값을 start의 앞에 추가하기 때문에 end - 1 
	   2)의 경우 start가 가리키는 값을 end의 뒤에 추가하기 때문에 start + 1
	   (서로 다른 값을 비교하다가 같은 값을 추가해 주었으니 추가해준 값과 같은 것을 가리키는 것을 이동)

	   이렇게 진행하고 나서 
	   DP[N][M] = Arr[N]부터 Arr[M]까지 팰린드롬을 만들기 위해 추가해야 하는 최소 숫자 갯수가 된다.
	   즉, 정답은 DP[1][N] (인덱스를 1부터 시작함)
*/
#include<iostream>
#include<algorithm>

using namespace std;

int n;
int arr[5001];
int d[5001][5001];

int go(int st, int en) {
	if (st > en) return 0;
	if (d[st][en] != -1) return d[st][en];

	if (arr[st] == arr[en]) d[st][en] = go(st + 1, en - 1);
	else d[st][en] = min(1 + go(st + 1, en), 1 + go(st, en - 1));

	return d[st][en];
}

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> arr[i];

	for (int i = 0; i <= n; i++)
		for(int j = 0; j<=n; j++)
		d[i][j] = -1;
	
	cout << go(1, n);
}