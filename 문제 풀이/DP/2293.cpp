/*
작성자 : 이상수
일시 : 2021.05.25
제목 : 동전 1 - 2293
풀이 : 거스름돈을 주는 방식을 생각하면 편하다.
       N원의 거스름돈을 주어야 한다고 생각하고
	   잔돈의 종류가 cost[i]로 있다고 생각해보자.
	   가장 작은 단위의 잔돈으로 모두 몰아서 줄 수도 있고
	   가장 작은 단위의 잔돈과 바로 위의 단위를 가진 잔돈과 함께 줄 수도 있다.
	   다시 말해
	   1, 2, 5로 10을 만든다고 가정하면
	   베이스는 가장 작은 단위인 1을 기준으로 한다.
	   1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1      이를 기준으로
	   1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 2
	   1 + 1 + 1 + 1 + 1 + 1 + 2 + 2
	   1 + 1 + 1 + 1 + 2 + 2 + 2
	   1 + 1 + 2 + 2 + 2 + 2
	   2 + 2 + 2 + 2 + 2                          와 같이 바뀌게 된다.

	   즉, 가장 작은 단위를 가지는 것 부터 시작하여
	   가장 작은 수 부터 가장 큰 수까지 그 값을 더해가면 된다.
	   D[0] = 1 (아무것도 쓰지 않는 경우 한 가지)
	   D | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
	       1  
		       1
			       1
				      ....                          -> 1을 사용하는 경우
		   1 
		       2  
			       3
				       3
					      ....                      -> 2를 사용하는 경우
	   
	   이처럼 가장 작은 단위의 비용을 가장 작은 수부터 더해가는 경우를 사용하여
	   D[K] = D[K] + D[K - COST[N]] 이라는 점화식을 가지게 된다.


	   내가 접근한 방식 (해결 못함)
	   1. K가 쓰이는 수들의 배수라면 +1을 하는것이 아닌가 -> 배수가 아닌 더하는 값에서의 쓰임이 있기 때문에 틀림
	   2. 1번에서 파생되어 쓰이는 수들을 조합하여 서로 더한 다음 배수를 찾는것이 아닌가 -> 몇번 더하고 몇번 조합할지 그 제한이 없음

	   풀이를 보고 나서 깨달은 점
	   1. DP문제중 Bottom-Up 방식이라고 해서 무조건 한번에 그 수를 정해야 하는것이 아니다. -> 기준을 통해 차곡 차곡 쌓아가는 방식 또한 존재한다는것
	   2. 사람이 푸는 즉, 내가 푸는 방식이 어떤것인지 생각해보자.
	     -> 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1    
			1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 2
			1 + 1 + 1 + 1 + 1 + 1 + 2 + 2
			1 + 1 + 1 + 1 + 2 + 2 + 2
			1 + 1 + 2 + 2 + 2 + 2
			2 + 2 + 2 + 2 + 2 
			...
			가장 작은 단위로 구하고자 하는 수의 경우의 수를 구한 다음 --- (1)
			그 다음 단위의 수로 가장 작은 단위의 몇 부분을 때서 구할 수 있는지 확인하고 진행한다. (마지막 1 + 1을 2로 만드는 방식) --- (2)
			이 과정을 자세하게 들여다 보면 (1)의 과정 또한 (2)를 모두 진행한 결과이다.
			즉, D[10]을 구하기 위해 D[9]에 1을 더한 것이고
			D[9]는 D[8]에 1  // D[8]은 D[7]에 1 이렇게 진행하다 보면 가장 작은 수인 D[1]은 D[0] + 1이 된다.
			즉, 가장 작은 수에 가장 작은 단위부터 시작하는 Bottom-Up 방식이다.
			이렇게 쌓아 올리고 나서 다시 2에 대해 진행한다.
			그렇다면 1을 사용하는 경우는 모두 끝났고, 2를 사용하는 경우만 적용하면 되기 때문이다.

			아래서부터 쌓아 올라가기 때문에 겹치는 경우의 수를 걱정할 필요는 없다.
			D[3]에는 1 + 1 + 1 / 1 + 2 가 있고 이는 
			D[2] + 1과 D[1] + 2 와 같고, 쌓아 올린것이기 때문이다.
	    

		항상 느끼지만 설명을 하는것이 정말 어렵다.
		최대한 쉽게 요약하여 설명해보자면
		1과 2로 6을 만드는 것은
		1만 사용한 5에 1을 더하는 방법이고
		1과 2를 사용한 4에 2를 더하는 방법이다.
		이 과정이 차례대로 이루어지지 않고 한번에 하나의 수에 일어난다면
		겹치는 경우가 생기게 된다.
		Ex) 2 -> 1 + 1 // 2 // ㄱ
		    3 -> 1 + 1 + 1 // 2 + 1 (D[2] + 1)			/////		 1 + 2 (D[1] + 2)      ----> 겹치게 됨
*/
#include<iostream>
#include<algorithm>

using namespace std;

int n, k;
int d[10001];
int cost[101];

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	cin >> n >> k;
	for (int i = 0; i < n; i++)
		cin >> cost[i];

	d[0] = 1;
	for (int i = 0; i < n; i++)
		for (int j = cost[i]; j <= k; j++)
			d[j] += d[j - cost[i]];

	cout << d[k];
}