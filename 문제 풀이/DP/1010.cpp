/*
작성자 : 이광민
일시 : 2021.07.13
제목 : 1010 - 다리 놓기
풀이 : 문제 분류가 조합찾기 여서 처음에 조합 공식으로 접근했다가 그 범위가 long long의 범위마저 벗어나게 되어
       다른 풀이를 찾아보았다.

	   주어진 점들을 다시 한번 보면
	   n개와 m개의 두 점이 있고 이 두 점이 항상 n <= m일 때 두 점을 잇는 방법을 찾는 문제이다.
	   그렇다면, n개의 점에서 가장 상단의 한개를 m개의 점 가장 상단에 이어 붙이면
	   이 경우는 "n-1개의 점을 m-1개의 점에 이어 붙이는 경우"로 볼 수 있다.

	   마찬가지로 n개의 점에서 가장 상단의 한개를 m개의 두번째 점에 이어 붙이면
	   이 경우는 "n-1개의 점을 m-2개의 점에 이어 붙이는 경우"로 볼 수 있다. (중복은 조합에서 허용되지 않는다)

	   이 처럼 짜여진 규칙이 있고 기본 베이스가 되는 값도 찾을 수 있기 때문에 (베이스 => 1개의 점에서 M개의 점에 이어 붙이는 방법 -> M가지)
	   다이나믹 프로그래밍으로 접근해보도록 하자.

	   DP[N][M] = N개의 점에서 M개의 점으로 중복없이 이어 붙이는 방법
	   DP[N][M] = DP[N-1][M-1] + DP[N-1][M-2] + DP[N-1][M-3] + ... + DP[N-1][1] 이 된다.

	   이를 적용시키기 위해 3중 포문을 이용하여 각 값들을 구해주고
	   테스트케이스에 대해 들어오는 값의 결과를 바로 출력해주면 된다.
*/
#include<iostream>

using namespace std;

int d[31][31];

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	for (int i = 1; i <= 30; i++)
		d[1][i] = i;

	for (int i = 2; i <= 30; i++) {
		for (int j = i; j <= 30; j++) {
			for (int k = j - 1; k >= 1; k--) {
				d[i][j] += d[i - 1][k];
			}
		}
	}
	
	int t;
	cin >> t;
	while (t--) {
		int a, b;
		cin >> a >> b;
		cout << d[a][b] << '\n';
	}
}