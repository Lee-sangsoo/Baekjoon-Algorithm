/*
작성자 : 이광민
일시 : 2021.05.31
제목 : 12865 - 평범한 배낭
풀이 : 그 유명한 KnapSack문제
       특정 물건을 가져갈 것인가 안가져갈 것인가를 결정해야 하는 문제

	   DP 식에 대해 설명을 먼저 하자면
	   DP[N][K] = N번째 물건을 탐색 중이고 배낭의 무게가 K일때의 최대 가치
	   이 점화식을 보고 확인 가능한 것은

	   1. N번째 물건을 가져갈 수 있는 경우
	   2. N번째 물건을 가져갈 수 없는 경우

	   2가지로 나뉜다.
	   1번의 경우 또 다시 2가지로 나뉘게 되므로 먼저 2번의 경우를 보게 되면

	   현재 배낭의 무게와 N번째 물건의 무게의 합이 K를 넘는 경우 이 물건은 가져가지 못하게 된다.
	   즉, N번째 물건을 가져가지 못하고 N-1번째 물건을 선택했을 때의 무게 K의 값을 그대로 가져가게 된다.
	   (현재 물건을 선택하지 않아서 무게는 유지가 되고 그 때의 최대값은 이 전 탐색 물건의 값이므로)
	   이 경우에는 DP[N][K] = DP[N-1][K]가 된다.

	   1번의 경우
	   무조건 가져가면 안된다. 왜냐하면 현재 물건을 포기하고 해당 무게만큼의 공간을 다른 더 높은 가치를 가지는 물건을 챙기면 더 높은 가치를 가질 수 있기 때문이다.
	   이 경우를 처리하기 위해
	   해당 물건을 가져가는 경우, 가져가지 않는 경우 모두 처리하게 되면 매우 많은 경우의 수가 나오기 때문에
	   1부터 K까지의 모든 무게의 경우를 완전탐색하여 처리한다.
	   즉, 물건을 가져갈 수 있는 경우
	   DP[N][K] = MAX(DP[N-1][K], DP[N-1][K-Wei[N]] + Val[N])
	   로 확인한다. (현재 물건을 챙기지 않은 경우, 현재 물건을 챙긴 경우를 비교하여 최대값으로 가져간다.)

	   다시 풀어서 설명하면
	   DP[N][K] = DP[N-1][K]는 "이 전의 물건까지 구성된 무게 K 배낭의 최대 가치"가 되고
	   DP[N][K] = DP[N-1][K-Wei[N]] + Val[N]는 "현재 물건까지 구성된 무게 K 배낭의 최대 가치"가 된다.

	   결론
	   1. 현재 물건을 가져갈 수 없다.
	   2. 현재 물건을 가져갈 수 있다.
	    2-1. 현재 물건을 선택한다.
		2-2. 현재 물건을 포기한다.
*/


#include<iostream>
#include<algorithm>

using namespace std;

int n, k;
int val[101];
int wei[101];
int d[101][100001];

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	cin >> n >> k;
	for (int i = 1; i <= n; i++) 
		cin >>  wei[i] >> val[i];
	
	for (int i = 1; i <= n; i++) { 
		for (int j = 1; j <= k; j++) { 
			if (j < wei[i])
				d[i][j] = d[i - 1][j];
			else
				d[i][j] = max(d[i - 1][j], d[i - 1][j - wei[i]] + val[i]);
		}
	}
	cout << d[n][k];
}