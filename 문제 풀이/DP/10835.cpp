/*
작성자 : 이상수
일시 : 2021.05.07
제목 : 카드게임 - 10835
풀이 : DP에서 탑다운 방식의 풀이가 익숙하지 않아 찾아본 문제
       따로 탑다운을 사용하면 간단하게 해결되는 문제집이 있어서 풀어보려고한다.

	   이 문제에서 생각할 것이 몇가지 있으며, 최종적으로 무엇을 실수하였는지에 대해 적어보고자 한다.

	   생각할 것
	   1. 메모제이션에서 언제 값이 증가하는가
	   2. 언제 종료를 하는가

	   이 두가지에 대해 설명하자면, 왼쪽의 카드덱 보다 오른쪽의 카드덱의 숫자가 더 높을 때 점수를 낼 수 있기 때문에
	   조건문을 통해 해당 방식을 추가하고, d[a][b] = max(d[a][b], dp(a, b+1) + arr[1][b])로 두면 된다.
	   arr[1][b]의 경우 오른쪽(1)덱의 b번째 숫자를 더해주는 방식을 사용하면 된다.

	   종료를 하는 경우는 두 카드 중 하나가 모두 사용이 된 경우를 확인하면 된다.
	   즉, a와 b가 n보다 커지는 경우를 확인하면 된다.

	   이 외에는 점수가 나는 경우가 없기 때문에
	   왼쪽만 버리는 경우
	   왼쪽과 오른쪽을 함께 버리는 경우를 돌아가며 확인해주면 된다.

	   실수한 것
	   이 문제에서 dp의 값이 0인 경우가 있기 때문에
	   Ex) (2 2 2) (2 2 2) 인 경우 끝까지 점수가 나지 않음
	   이 문제에서 시작값을 0으로 두면 정확한 메모제이션 방식을 사용할 수 없기 때문에 시간초과가 난다.
	   이를 방지하기 위해 -1로 초기화를 하고 진행하면 된다.
*/
#include<iostream>
#include<algorithm>

using namespace std;

int n;
int arr[2][2001];
int d[2001][2001];

int dp(int a, int b) {
	if (a > n || b > n) return 0;
	if (d[a][b] != -1) return d[a][b];

	if (arr[0][a] > arr[1][b])
		d[a][b] = max(d[a][b], dp(a, b + 1) + arr[1][b]);
	d[a][b] = max(d[a][b], dp(a + 1, b));
	d[a][b] = max(d[a][b], dp(a + 1, b + 1));
	return d[a][b];
}

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	cin >> n;
	for (int i = 0; i < 2; i++)
		for (int j = 1; j <= n; j++)
			cin >> arr[i][j];

	for (int i = 0; i <= n; i++)
		for (int j = 0; j <= n; j++)
			d[i][j] = -1;

	cout << dp(1, 1);;
}