/*
작성자 : 이광민
일시 : 2021.07.01
제목 : 17088 - 등차수열 변환
풀이 : N의 최대값이 10만이기 때문에 브루트 포스를 통한 풀이는 불가능하다. (TLE)
       '등차 수열'의 정의를 사용하여 풀면 되는데, A[i+1] - A[i]의 값이 모든 N에서 동일한 것이 등차수열이다.
	   문제에서 사용 가능한 연산은 2가지로 각 수에 최대 1번 적용 가능하며 1을 더하거나 1을 빼는 연산이 가능하다.

	   이를 다시 말하면 굳이 모든 수에 연산을 적용시켜가며 확인할 필요 없이
	   첫번째 수와 두번째 수에 -1, 0, 1 한 값의 차가 나머지 수에서도 유지가 되는지 확인하며
	   연산의 횟수만 비교를 하게되면 더욱 빠르게 최소 연산 횟수를 찾을 수 있다.

	   우선 두 수에 -1, 0, 1을 더해주어 비교해야 하기 때문에
	   2중 반복문을 통해 총 9번의 반복을 진행한다.
	   이 때, 두 반복문의 변수가 0이 아니라면 그 말은 첫번째 수와 두번째 수에 연산이 진행되었다는 말이기 때문에
	   연산 횟수를 세는 변수를 증가시켜준다.

	   그 다음 두 수의 차를 새로운 변수에 저장시켜 두고 그 수를 등차 수열의 값으로 가지고 진행한다.

	   앞의 두 수는 비교를 진행하였기 때문에 세번째 수 부터 등차수열이 가능한지 확인하면 된다.
	   두번째 수를 저장하고 있는 변수에서 등차값을 더한 값을 저장하는 변수를 가지고 시작하며
	   이 값에 등차값을 꾸준히 더해가며 과정을 진행해주면 된다.

	   새로운 수에도 2가지 연산을 진행할 수 있으며
	   연산을 진행했다면 카운트를 증가시켜준다.

	   이 때, 연산을 진행한 2가지, 연산을 하지 않은 기본 수 모두 등차값에 맞지 않다면 이는 불가능한 등차수열이기 때문에
	   이를 판단하기 위한 bool 변수를 통해 값의 비교를 진행하지 않도록 한다.

	   이렇게 최종적으로 9가지의 경우에 대해 가장 적은 횟수를 가지는 연산을 출력해주면 된다.

	   모든 경우를 생각하는것이 아니라 문제의 조건인 등차수열에 중점을 두고 풀이한 문제. (시야를 넓히자)
*/
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

int n;
int arr[100001];

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	cin >> n;
	for (int i = 0; i < n; i++)
		cin >> arr[i];

	int ans = -1;
	for (int i = -1; i < 2; i++) {
		for (int j = -1; j < 2; j++) {
			int cnt = 0;
			if (i != 0) cnt++;
			if (j != 0) cnt++;

			int num1 = arr[0] + i;
			int num2 = arr[1] + j;
			int diff = num2 - num1;

			int cur = num2;
			bool chk = true;
			for (int k = 2; k < n; k++) {
				cur += diff;
				if (arr[k] == cur) continue;
				else if (arr[k] - 1 == cur) {
					cnt++;
					continue;
				}
				else if (arr[k] + 1 == cur) {
					cnt++;
					continue;
				}

				chk = false;
				break;
			}
			if (chk) {
				if (ans == -1) ans = cnt;
				else ans = min(ans, cnt);
			}
		}
	}
	cout << ans;
}