/*
작성자 : 이광민
일시 : 2021.06.30
제목 : 9657 - 돌 게임 3
풀이 : 조합이 아닌 DP로 문제를 풀었다.
       d의 값은 상근이를 기준으로 하여 1이면 상근이가 이기는 경우가 저장되어 있다.

	   어떻게 수식을 구성할까 했는데, 이를 다시 생각하면
	   N의 기준에서 봤을 때 N-1, N-3, N-4 번째에서 만약 상근이가 진다면
	   N번째에서는 상근이가 이길 수 있다. (위 3가지 경우에서 상근이가 마지막으로 가져갈 수 없지만, N번째는 가져갈 수 있기 때문)

	   1.
	   그렇기 때문에 N-1, N-3, N-4 의 값에서 상근이가 모두 이겼다면 N번째에서는 상근이가 이길 수 있는 방법이 없다.
	   ( if (min({d[i-1], d[i-3], d[i-4]}) == 1) 이 부분 )

	   2.
	   반대로 N-1, N-3, N-4 의 값에서 상근이가 한번이라도 지는 경우가 생긴다면 상근이는 N번째에서 이길 수 있다.

	   문제에서 주어지는 '완벽한 게임' 이란 정확한 설명은 없지만, 내가 이길 수 있는 경우에는 무조건 이기는 게임을 의미하는 것 같다.

	   그렇기 때문에 위 2가지 케이스에서 모든 값을 판별할 수 있다.
*/
#include<iostream>
#include<algorithm>

using namespace std;

int n;
int d[1001]; // 1 = SK WIN

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	cin >> n;
	d[1] = 1;
	d[2] = 0;
	d[3] = 1;
	d[4] = 1;
	
	for (int i = 5; i <= n; i++) {
		if (min({d[i-1], d[i-3], d[i-4]}) == 1) d[i] = 0;
		else d[i] = 1;
	}
	if (d[n] == 0) cout << "CY";
	else cout << "SK";
}