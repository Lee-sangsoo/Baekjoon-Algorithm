/*
작성자 : 이상수
일시 : 2021.04.15
제목 : K번째 수 - 1300
풀이 : 문제 분류부터가 이분탐색이 아닌거 같지만 이분탐색으로 풀 수 있는 문제!
       라고 적혀있다.
	   정말 어렵다... 해답을 보고 풀었고 풀이를 보았지만 
	   여러가지 이해 안되는 부분이 많다.

	   1. 어째서 최대값은 n*n이 아니라 k로 두어야 통과 되는가
	   2. 나오지 않는 숫자를 어떻게 넘어가는가
	   3. 이 문제는 어떻게 이분탐색이 가능한가

	   해당 부분에 대해 이해한 바는 다음과 같다.
	   
	   1 -> 모든 k번째로 작은 수는 k 이하이다.
	   2 -> 1번에서 파생되는 것인데, 이분탐색을 통해 최소값을 찾기 때문
	   3 -> 1번과 2번을 증명하면 이분탐색이 가능한것을 알 수 있다.

	   Ex1) N = 3 일때 -> B[] = 1 2 2 3 3 4 6 6 9
	        N = 4 일때 -> B[] = 1 2 2 3 3 4 4 4 6 6 8 9 12 12 16
			모든 K번째에 대해 배열의 수 중 K번째로 작은 수는 K 이하이다.
			그렇기 때문에 최대 수를 K로 두어도 된다.

	   Ex2) P(x)가 참인 가장 작은 x를 찾는것이 요점이므로
	        조건이 참이되는 x를 찾는다고 하더라도 x보다 작은 값이 존재하는지
			확인하기 위해 이분탐색을 통해 값을 변경해 나가기 때문에 나오지 않는다.

	   이러한 이유들 때문에 이분탐색으로 이 문제를 풀 수 있으며
	   최종적으로 정답에 이를수있다.

	   문제에 여러가지 증명과 생각이 필요하다.

	   정렬 후에 K번째를 찾는다 라는 생각에서
	   K보다 작은 값이 몇개인가를 찾는 방식으로 바뀌는것이다.

*/
#include<iostream>

using namespace std;

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	int n, k;
	cin >> n >> k;
	
	int st = 1, en = k;
	while (st <= en) {
		long long cnt = 0;
		long long mid = (st + en) / 2;
		for (int i = 1; i <= n; i++) cnt += mid / i < n ? mid / i : n;
		if (cnt < k) st = mid + 1;
		else en = mid - 1;
	}
	cout << en + 1;
}