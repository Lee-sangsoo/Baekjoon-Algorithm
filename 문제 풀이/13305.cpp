/*
작성자 : 이상수
일시 : 2021.01.28
제목 : 주유소 - 13305
풀이 : 그리디 문제는 돈 쓰는 것과 같다
       같은 물건이라면 최대한 적은 돈으로 최대한 많이 쓸 수 있는 걸 고르면 된다.

	   기본적으로 인수가 크기 때문에 반복문은 한번만 쓰는게 좋다.
	   
	   현재 내가 있는 도시의 기름 값과 다음 도시의 기름값을 비교해서 
	   현재 도시의 기름 값보다 다음 도시의 기름 값이 더 비싼 경우와
	   현재 도시의 기름 값보다 다음 도시의 기름 값이 더 싼 경우를 나눠 생각하면 된다.

	   전자 라면 해당 도시의 주유소를 스킵하기 위해 다음 다음 도시까지의 거리를 생각하여 기름을 사고
	   후자 라면 다음 도시 까지 거리만큼의 기름만 사도록 한다.

	   이를 구현한 코드이다.
제한사항 : 2 <= N <= 100,000
		   가장 왼쪽 도시부터 가장 오른쪽 도시 까지의 거리 = 1이상 1,000,000,000 이하
		   리터당 가격은 1이상 1,000,000,000 이하
*/
#include <iostream>

using namespace std;

long long answer = 0;
long long dist[100001], cost[100001];
int n;

int main() {
	// 입력 시작
	cin >> n;
	for (int i = 0; i < n - 1; i++) {
		int tmp = 0;
		cin >> tmp;
		dist[i] = tmp;
	}

	for (int i = 0; i < n; i++) {
		int tmp = 0;
		cin >> tmp;
		cost[i] = tmp;
	}
	// 입력 끝

	int now = 0, d = dist[0]; // 현재 있는 도시 = now / 다음 도시 까지의 거리 = d
	for (int i = 1; i < n - 1; i++) {
		if (cost[now] <= cost[i]) { // 전자
			d += dist[i];
		}
		else { // 후자
			answer += (d * cost[now]);
			d = dist[i];
			now = i;
		}
	}

	if (d != 0) { // 통과 하고 생각 해보니 이 부분은 조건문을 하지 않아도 되는것 같다
				  // 없어도 된다 (확인 완료)
		answer += (d * cost[now]);
	}

	cout << answer;
}