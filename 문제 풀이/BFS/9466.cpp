/*
작성자 : 이상수
일시 : 2021.03.23
제목 : 텀 프로젝트 - 9466
풀이 : DFS를 사용하여 사이클이 아닌 노드들을 찾는 문제이다.
       생각보다 사이클을 구하는 문제에서 많이 막힌다.
	   (공부할 필요가 있다 (다양한 문제를 풀어보자)

	   우선 사이클의 크기를 구하기 위해 2가지가 필요하다.
	   1. 해당 노드의 탐색에서 시작 노드가 무엇인지 (first)
	   2. 해당 노드를 몇번째로 탐색했는지 (chk)

	   first 배열의 경우 이미 방문한 노드를 재방문 하였을 때
	   해당 노드를 현재 탐색중인 값에서 재탐색한것이 맞느지 확인하기 위해 사용된다.
	   예를 들어 1번부터 탐색을 진행하며
	   1 -> 2 -> 3 -> 4 -> 2 였다면
	   1은 사이클이 아니지만 이미 탐색을 하여 chk값이 0이 아니며
	   이 때 만약 다음 탐색에서
	   5 -> 1 과 같은 상황이 오게 되면
	   first 배열이 없다면 이미 방문한 노드를 방문하였구나! 라는 
	   판단을 하여 사이클로 인식하게 된다.
	   하지만, first 배열을 사용하여 기록을 하게 되면
	   첫번째 상황에서 first[1] = 1로 기록이 되고
	   두번째 상황에서 1을 방문하였을 때 st의 값은 5이기 때문에
	   이 두개의 값이 같지 않기 때문에 올바른 사이클이 아니라는 결론을 낼 수 있다.

	   (올바른 사이클이 아니다 -> 0 반환
	    올바른 사이클이다 -> cnt - chk[x] 반환 (현재 탐색 횟수 - 처음 해당 노드 방문시 횟수)
	   
	   chk배열은 평소 bool로 사용하던 때와 달리 
	   int 배열로 선언하여 탐색에서 몇번째로 탐색을 하게 되었는지로 사용하도록 한다.


	   사이클에 대해서는 매우 다양한 접근방법이 있는것 같다.
	   문제가 다양하고 풀이가 다양하기 때문에

	   많은 문제와 많은 풀이를 해보는게 중요하다.

	   다른 풀이
	   1. 더이상 보지 않아도 되는 노드를 저장하는 배열 하나를 만든다.
	   2. 노드 방문 여부를 저장하는 배열을 만든다.
	   3. 만약 DFS탐색을 진행하면서 이미 방문한 노드를 방문 하였을 때,
	      1번에서 정의한 배열값이 false일 때만 정답을 유추하여 값을 반환한다.
	   4. 3번에서 값을 반환하게 된다면 그 값은 사이클의 크기가 되며
	   그 방법은 다음과 같다.
	   x = 현재 탐색 노드
	   y = arr[x]
	   chk[y]가 true이며 1번에서 정의한 배열이 false일 때
	   for(int i = y; i != x; i = connect[i]){
			cnt++;//연결된 점들 개수 세기
		}
			cnt++;//자기 자신
		(처음 진행한 while 사용과 비슷하다)
*/

#include<iostream>
#include<vector>

using namespace std;

int n;

int arr[100001];
int chk[100001];
int first[100001];

int dfs(int st, int x, int cnt) {
	if (chk[x]) {
		if (first[x] != st) return 0;

		return cnt - chk[x];
	}

	chk[x] = cnt;
	first[x] = st;
	return dfs(st, arr[x], cnt + 1);
}

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	int t;
	cin >> t;
	while (t--) {
		cin >> n;
		for (int i = 1; i <= n; i++) {
			cin >> arr[i];
			chk[i] = 0;
			first[i] = 0;
		}
			

		int ans = n;
		for (int i = 1; i <= n; i++) {
			if (chk[i]) continue;
			int res = dfs(i, i, 1);
			if (res != -1) ans -= res;
		}
		
		cout << ans << '\n';
	}
	
}