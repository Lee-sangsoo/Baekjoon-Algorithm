/*
작성자 : 이상수
일시 : 2021.03.31
제목 : 강의실 배정 - 11000
풀이 : 한번의 시간초과를 거쳐서 푼 문제
       이 문제는 최대 20만의 n을 가지는 문제이다.
	   처음 문제를 풀 때 조건문을 잘 이용하면 2중 반복문을 사용해도 풀이가 가능하겠지
	   라는 생각에 제출을 해보았으나 
	   내가 푼 방식은 시작 가능한 수업이 몇개인지
	   완전 탐색을 통해 조건문으로 조금씩 바꾸게 하려고 하였으나
	   만약 모든 수업이 중첩이 된다고 가정하면
	   이 방법은 매우 긴 시간이 걸리게 된다. (시간초과)

	   그래서 힌트를 받아서 풀었다. 
	   힌트는 우선순위 큐를 사용하는 방식이였다.

	   처음 접근 방식은 하나의 강의실에서 수행 가능한 수업은 몇개일까? 라는 접근이였다면
	   정답코드의 접근 방식은 지금 이 수업 중인데 다음 수업이 가능한가? 이다.
	   (우선순위 큐 하나하나를 강의실로 생각하면 된다.
	       강의실을 사용할때는 push되어 있고 수업이 끝나면 pop하여 빠지는 방식)
	   우선순위 큐를 사용하여 우선 가장 빠른 시작 시간을 가지는 수업의
	   끝나는 시간을 우선순위 큐에 넣는다 그리고 새로운 수업에 대해 해당 수업이
	   끝나는 시간보다 새로운 수업의 시작 시간이 크거나 같다면 기존의 수업을 
	   우선순위 큐에서 pop하여 끝내주고 새로운 수업을 큐에 넣어준다.
	   반대로 기존의 수업이 더 늦게 끝난다면 우선순위 큐(대학교)에 새로운 노드(강의실)를
	   생성해준다. 이 과정을 통해 마지막 수업의 탐색을 마치고 나서
	   우선순위 큐의 크기를 확인하면 그게 최종 정답이 된다.
*/
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>

using namespace std;

int n;
bool chk[200001];

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	cin >> n;
	vector<pair<int, int>> arr;
	priority_queue<int, vector<int>, greater<int>> q;
	for (int i = 0; i < n; i++) {
		int s, t;
		cin >> s >> t;
		arr.push_back({ s, t });
	}

	sort(arr.begin(), arr.end());
	q.push(arr[0].second); // 가장 빠르게 시작하는 수업의 끝나는 시간을 삽입
	
	for (int i = 1; i < n; i++) {
		if (arr[i].first >= q.top()) { // 새로운 수업을 기존 강의실에서 시작 가능하다면
			q.pop(); // 기존 수업을 빼주고
			q.push(arr[i].second); // 새로운 수업을 넣어준다.
		}
		else { // 새로운 수업을 기존 강의실에서 시작하지 못한다면
			q.push(arr[i].second); // 새로운 강의실을 할당해준다.
		}
	}

	cout << q.size(); // 마지막에 수업을 진행중인 강의실의 개수를 출력한다.
}