/*
작성자 : 이상수
일시 : 2021.02.25
제목 : 퇴사 - 14501
풀이 : 브루트포스로 한번 풀었던 문제인데, 앞의 값이 뒤에 값에 의존적이지 않고 
       변하지 않기 때문에 DP로 풀이가 가능하다.

	   처음 점화식을 구할 때, 어떻게 접근해야 할지 막막했는데
	   블로그를 통해 힌트를 얻었다.
	   D[N] = N일에 받을 수 있는 최대 급여
	   로 두고 접근하면 된다.

	   즉, D[1] = 1일에 받을 수 있는 최대 급여로 모든 상담은 최소 하루가 걸리기 때문에
	   이 값은 0이 된다.
	   
	   1일부터 상담을 진행할 수도 있고 안할 수도 있다.

	   상담을 진행하지 않는 경우는 D[내일날짜] 에
	   오늘 날짜에 받을 수 있는 최대 급여와 
	   내일 날짜에 받을 수 있는 최대 급여를 비교하여 큰 값을 저장하면 된다.

	   상담을 진행하는 경우에는 D[오늘 날짜 + 상담에 걸리는 기간]에
	   상담이 끝나는 날에 있는 최대 급여와
	   오늘 받을 수 있는 최대 급여 + 상담을 진행했을 때 얻는 수익
	   을 비교하여 큰 값을 저장하면 된다.

	   이렇게 진행하면서, 마지막 날에 상담이 하루가 걸린다고 하면
	   이는 하루안에 끝낼 수 있지만, 프로그래밍을 할 때에는
	   이 값이 N + 1일에 저장되기 때문에
	   1일부터 N + 1일 까지의 급여 중 가장 큰 급여를 선택하여 출력 해주면 된다.
*/
#include<iostream>
#include<algorithm>

using namespace std;

int n;
int t[16];
int p[16];
int d[16];

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	cin >> n;
	for (int i = 1; i <= n; i++) 
		cin >> t[i] >> p[i];
	
	for (int i = 1; i <= n; i++) {
		if (i + 1 <= n + 1) d[i + 1] = max(d[i + 1], d[i]);
		if (i + t[i] <= n + 1) d[i + t[i]] = max(d[i + t[i]], d[i] + p[i]);
	}

	int ans = 0;
	for (int i = 1; i <= n + 1; i++)
		ans = max(ans, d[i]);

	cout << ans;
}