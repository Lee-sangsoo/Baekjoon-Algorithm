/*
작성자 : 이상수
일시 : 2021.02.24
제목 : 이친수 - 2193
풀이 : D[N][K] = 길이가 N이고 마지막 수가 K인 이친수의 개수
       K = 0 OR 1

	   1이 두번 연속으로 올 수 없기 때문에
	   1이나 0으로 끝난 경우 다음으로 0이 올 수 있고
	   0으로 끝난 경우에만 1이 올 수 있다.
	   이 경우를 나누어
	   D[N][0] = D[N-1][0] + D[N-1][1];
	   D[N][1] = D[N-1][0];
	   이 된다.

	   이 두가지를 합하여 출력 해주면 된다.
	   범위가 생각보다 매우 크기 때문에
	   D배열과 ans 모두 long long으로 처리하면 된다.


	   이 문제는 1차원 DP로 풀 수도 있는데, 접근방식은 다음과 같다
	   D[N] = N자리 이친수 라고 했을 때,
	   N번째 자리에 0과 1이 올 수 있다.
	   그렇다면 

	   N번째 자리에 0이 온다면 N-1번째 자리에는 무엇이 오든 상관이 없다.
	   그러므로 D[N-1]과 같다.

	   N번째 자리에 1이 온다면 N-1번째 자리에는 0이 와야 한다.
	   여기서 N과 N-1번째 자리를 묶어서 생각하게 되면
	   N-2번째 자리에 무엇이 오든 상관 없이 01을 넣게 되는 것이다.
	   즉, N-1번째 자리에 0이 와야 하고 N번째 자리에 1이 와야 하는것을 묶어서
	   01이 오게 되면 N-2번째 자리에는 무엇이 오든 상관 없이 01을 붙이면 되기 때문에
	   D[N-2]와 같아진다.

	   이 둘을 합쳐 D[N] = D[N-2] + D[N-1] 과 같다.
*/
#include<iostream>

using namespace std;

int n;
long long d[91][2];

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	cin >> n;
	d[1][1] = 1;
	for (int i = 2; i <= n; i++) {
		d[i][0] = d[i - 1][0] + d[i - 1][1];
		d[i][1] = d[i - 1][0];
	}

	long long ans = d[n][0] + d[n][1];
	cout << ans;
}